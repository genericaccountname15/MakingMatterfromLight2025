"""
xray_spectra.py

Defines the XraySpectra class, which reads the Xray bath's energy spectral data folder,
with methods to plot and sample a probability density function based on the data.
The data was taken from the 2018 paper's zenodo records repository.
The data was used to plot figures 4b and 5a in the 2018 paper.

Timothy Chew
1/8/25
"""
import os
import numpy as np
import matplotlib.pyplot as plt

class XraySpectra:
    """Xray spectra data set
    Args:
        file_dir (string): file directory address containing the xray spectra files in pickle format (.pickle)
        resolution (float, optional): resolution of xray energy bins for averaging over data sets. Defaults to 0.5eV.
    Attributes:
        file_dir (string): file directory address containing the xray spectra files in pickle format (.pickle)
        file_list (list): list of filenames within the directory specified
        resolution (float): resolution of xray energy bins for averaging over data sets (eV)
        energy (list[float]): all energy values from all datafiles
        nph (list[float]): all values of number of photons/eV/J/srad from all data files, corresponds to energy value
        nph_err (list[float]): standard deviation of number of photons/eV/J/srad from all data files
        avg_energy (list[float]): bin energies (centre of bin values)
        avg_nph (list[float]): bin-average photon count
        avg_nph_err (list[float]): bin-summed photon count standard deviation

    Methods:
        get_data() -> tuple(list[float], list[float], list[float]): Combines data from all 47 datasets
        bin_data: Bins data into energy bins and averages within the bins
        replicate_plot: Replicates the plot from literature as a sanity check
        filter_energies: Filters out energies and isolates a range of energies
        sample_pdf: Samples energergies from xray energy spectrum probability distribution
    """
    def __init__(self, file_dir, resolution=0.5):
        self.file_dir = file_dir
        self.file_list = os.listdir(file_dir)
        self.resolution = resolution

        self.energy, self.nph, self.nph_err = self.get_data()

        self.avg_energy, self.avg_nph = self.bin_data(self.get_energy(), self.get_nph(), bin_width=self.resolution())
        _, self.avg_nph_err = self.bin_data(self.get_energy(), self.get_nph_err(), bin_width=self.resolution(), err=True)

    
    def get_data(self):
        """Obtains and combines data from all datasets

        Returns:
            tuple: compiled data for (energy, number of photons, Nph error)
        """
        energy_list = np.array([])
        nph_list = np.array([])
        nph_err_list = np.array([])
        for file in self.file_list():
            if file.endswith('.pickle'):
                data = np.load(self.file_dir() + file, allow_pickle=True)
                energy_list = np.append(energy_list, data['E'][:][0], axis = 0)
                laser_energy = data['laser_energy']

                #normalise number of photons
                nph_list = np.append(nph_list, data['normalised_number']/laser_energy/np.pi/2, axis = 0)
                nph_err_list = np.append(nph_err_list, data['normalised_number_sem']/laser_energy/np.pi/2, axis = 0)
        
        return energy_list, nph_list, nph_err_list
            
    def bin_data(self, x, y, bin_width=0.5, err=False):
        """Bins arrays of x and y data points and averages
        y values in bins
        Generated by ChatGPT

        Args:
            x (list): list of x data points
            y (list): list of y data points
            bin_width (float, optional): resolution of bins. Defaults to 0.5.

        Returns:
            tuple (list, list): bin centre coordinates, height of bins
        """
        # Define bin edges (uniform or custom spacing)
        bins = np.arange(x.min(), x.max() + bin_width, bin_width)

        # Digitize x-values to bin indices
        bin_indices = np.digitize(x, bins)

        # Aggregate y-values into bins
        binned_y = np.zeros(len(bins) - 1)
        for i in range(1, len(bins)):
            in_bin = bin_indices == i
            if err:
                binned_y[i - 1] = np.sum(y[in_bin]) #sum uncertainties
            else:
                binned_y[i - 1] = np.mean(y[in_bin])

        # Bin centers for plotting
        bin_centers = 0.5 * (bins[:-1] + bins[1:])

        return bin_centers, binned_y
    
    def replicate_plot(self):
        """Replicates plot from the 2018 paper for sanity check
        """
        fig, ax = plt.subplots() #pylint: disable=unused-variable
        ax.set_title('Xray Spectrum')
        ax.set_xlabel('Xray Energy (eV)')
        ax.set_ylabel('Photons/eV/J/srad')
        ax.set_axisbelow(True)
        ax.grid()

        ax.fill_between(
            x = self.get_avg_energy(),
            y1 = 0,
            y2 = self.get_avg_nph() + self.get_avg_nph_err()/47,
            color = 'black'
        )
        
        ax.fill_between(
            x = self.get_avg_energy(),
            y1 = 0,
            y2 = self.get_avg_nph(),
            color = 'rebeccapurple'
        )

        ax.set_xlim(1300, 1550)
        ax.set_ylim(0, 1e11)

        plt.show()

    def filter_energies(self, min_energy, max_energy):
        """Filters energies between the 1.3-1.5keV energy range

        Args:
            min_energy (float): minimum energy (eV)
            max_energy (float): maximum energy (eV)
        """
        mask = (self.get_avg_energy() >= min_energy) & (self.get_avg_energy() <= max_energy)
        self.avg_energy = self.get_avg_energy()[mask]
        self.avg_nph = self.get_avg_nph()[mask]
        self.avg_nph_err = self.get_avg_nph_err()[mask]

    def sample_pdf(self, min_energy, max_energy, n):
        """Generates discrete probability distribution
        and returns a sample of energies

        Args:
            min_energy (float): minimum xray energy (eV)
            max_energy (float): maximum xray energy (eV)

        Returns:
            tuple (list, list): xray energies, probability per energy
        """
        self.filter_energies(min_energy, max_energy)
        prob = self.get_avg_nph()
        prob /= np.sum(prob) #normalisation

        samples = np.random.choice(self.get_avg_energy(), size = n, p = prob)

        return samples

    # ACCESS METHODS #########################################################
    def get_file_dir(self):
        return self.file_dir

    def get_file_list(self):
        return self.file_list
    
    def get_resolution(self):
        return self.resolution
    
    def get_energy(self):
        return self.energy
    
    def get_nph(self):
        return self.nph
    
    def get_nph_err(self):
        return self.nph_err
    
    def get_avg_energy(self):
        return self.avg_energy
    
    def get_avg_nph(self):
        return self.avg_nph
    
    def get_avg_nph_err(self):
        return self.avg_nph_err
